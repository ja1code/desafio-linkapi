const js2xmlparser = require('js2xmlparser')

module.exports = class SyncThirdPartyService {
  constructor (BlingApiAdapter, PipedriveAdapter, DatabaseSyncService) {
    this.blingApi = BlingApiAdapter
    this.pipedriveApi = PipedriveAdapter
    this.dbService = DatabaseSyncService

    this.totals = []
    this.erroredDeals = []
    this.lastExecution = 0
    this.lastDealId = 0
    this.lastwondDate = 0
  }

  async execute () {
    try {
      const deals = await this.getDealsFromPipedrive()

      if (!deals) return { status: 'success', msg: 'data synced' }

      for (const deal of deals) {
        await this.sendDealToBling(deal)
      }

      if (this.erroredDeals.length) this.retryErroredRequests()

      this.lastDealId = deals[0].id
      this.lastwondDate = deals[0].first_won_time.split(' ')[0]

      this.dbService.execute(this.totals, this.lastDealId, this.lastwondDate)

      return await this.buildResponse(deals.length)
    } catch (error) {
      console.log('>>', error)
      return error
    }
  }

  async getDealsFromPipedrive () {
    const filter_id = await this.getLastExecutionFilter() // eslint-disable-line

    const dealsRequest = await this.pipedriveApi.get('deals', { params: { status: 'won', sort: 'id DESC', limit: 1000, filter_id } })

    if (dealsRequest) return dealsRequest.data.data

    throw new Error('Invalid response from pipedrive')
  }

  async getLastExecutionFilter () {
    this.lastExecution = await this.dbService.getLastExecution()

    return await this.createPipedriveFilter(this.lastExecution.wonDate)
  }

  async sendDealToBling (deal) {
    if (deal.id > this.lastExecution.dealId) {
      const dealDate = deal.first_won_time.split(' ')[0]
      const request = await this.convertAndSendToBling(deal)
      if (request) this.accumulate(dealDate, deal.weighted_value)
    }
  }

  async convertAndSendToBling (deal) {
    const blingXml = await this.convertDealToXml(deal)
    const request = await this.blingApi.post('pedido/json/', { xml: encodeURIComponent(blingXml), apikey: process.env.BLING_API_KEY })

    if (request) {
      return true
    }

    this.erroredDeals.push(
      {
        request,
        deal
      }
    )

    return false
  }

  async convertDealToXml (deal) {
    const dealDate = new Date(deal.won_time)

    const formatedWonDate = `${dealDate.getDate() < 10 ? '0' + dealDate.getDate() : dealDate.getDate()}/${dealDate.getMonth() < 10 ? '0' + (dealDate.getMonth() + 1) : (dealDate.getMonth() + 1)}/${dealDate.getFullYear()}`

    const object = {
      data: formatedWonDate,
      numero: deal.id,
      vendedor: deal.user_id.name || '',
      cliente: {
        nome: deal.person_name,
        email: deal.person_id.email[0].value,
        fone: deal.person_id.phone[0].value
      }
    }

    if (deal.products_count) {
      const products = await this.getDealProducts(deal.id)

      if (!products) throw new Error()

      object.items = []

      for (const product of products) {
        object.items.push({
          item: {
            codigo: product.product_id,
            descricao: product.name,
            un: 'un',
            qtde: product.quantity,
            vlr_unit: product.sum
          }
        })
      }
    } else {
      object.itens = [
        {
          item: {
            codigo: 'XXX',
            descricao: 'Produto genÃ©rico',
            un: 'un',
            qtde: 1,
            vlr_unit: deal.weighted_value
          }
        }
      ]
    }

    return js2xmlparser.parse('pedido', object)
  }

  async getDealProducts (productId) {
    const productsRequest = await this.pipedriveApi.get(`deals/${productId}/products`)

    return productsRequest.data.data || false
  }

  async createPipedriveFilter (lastDate) {
    const date = new Date()
    const filterCreationRequest = await this.pipedriveApi.post('/filters', {
      name: `[AUTOGENERATED] @${date.toJSON()}`,
      conditions: {
        glue: 'and',
        conditions: [
          {
            glue: 'and',
            conditions: [
              {
                object: 'deal',
                field_id: 12470,
                operator: '>=',
                value: lastDate,
                extra_value: null
              }
            ]
          },
          {
            glue: 'or', // Pipedrive own iterface creates this empty condition, leaved here for safety porpouses
            conditions: []
          }
        ]
      },
      type: 'deals'
    })

    if (!filterCreationRequest) throw new Error()

    return filterCreationRequest.data.data.id || false
  }

  async accumulate (date, value) {
    const dateObject = this.totals.find(total => total.date === date)
    if (!dateObject) {
      this.totals.push({
        date,
        value
      })
    } else {
      dateObject.value += value
    }
  }

  async retryErroredRequests () {
    for (const erroredDeal of this.erroredDeals) {
      const { deal } = erroredDeal
      const dealDate = deal.first_won_time.split(' ')[0]
      const retry = await this.sendDealToBling(deal)
      if (retry) {
        const dealIndex = this.erroredDeals.indexOf(item => item.id === deal.id)

        this.erroredDeals.splice(dealIndex, 1)

        this.accumulate(dealDate, erroredDeal.weighted_value)
      }
    }
  }

  async buildResponse (dealsQtd) {
    return {
      status: 'success',
      details: {
        sent: dealsQtd - this.erroredDeals.length,
        errored: this.erroredDeals.length
      }
    }
  }
}
