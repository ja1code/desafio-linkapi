const js2xmlparser = require("js2xmlparser");

module.exports = class SyncThirdPartyService {
  constructor (BlingApiAdapter, PipedriveAdapter, DatabaseSyncService) {
    this.blingApi = BlingApiAdapter
    this.pipedriveApi = PipedriveAdapter
    this.dbService = DatabaseSyncService
    this.totals = []
  }

  async execute() {
    try {
      const lastExecution = await this.dbService.getLastExecution()

      const filter_id = await this.createPipedriveFilter(lastExecution.wonDate)

      const dealsRequest = await this.pipedriveApi.get('deals', { params: { status: 'won', sort: 'id DESC', limit: 1000, filter_id } })

      const deals = dealsRequest.data.data

      if (!deals) return { status: 'success', msg: 'data synced' }

      for (const deal of deals) {
        if (deal.id > lastExecution.dealId) {
          const dealDate = deal.first_won_time.split(' ')[0]
          this.accumulate(dealDate, deal.weighted_value)
          const blingXml = await this.convertDealToXml(deal)
          await this.blingApi.post('pedido/json/', { xml: encodeURIComponent(blingXml), apikey: process.env.BLING_API_KEY })
        }
      }

      const lastDealId = deals[0].id
      const wonDate = deals[0].first_won_time.split(' ')[0]

      this.dbService.execute(this.totals, lastDealId, wonDate)

      return { status: 'success', msg: 'data synced' }

    } catch (error) {
      console.log('>>', error)
      return error
    }
  }

  async accumulate (date, value) {
    const dateObject = this.totals.find(total => total.date === date)
    if (!dateObject) {
      this.totals.push({
        date,
        value
      })
    } else {
      dateObject.value += value
    }
  }

  async convertDealToXml (deal) { 
    const dealDate = new Date(deal.won_time)

    const formatedWonDate = `${dealDate.getDate() < 10 ? '0' + dealDate.getDate() : dealDate.getDate()}/${dealDate.getMonth() < 10 ? '0' + (dealDate.getMonth() + 1) : (dealDate.getMonth() + 1)}/${dealDate.getFullYear()}`
    
    const object = {
      data: formatedWonDate,
      numero: deal.id,
      vendedor: deal.user_id.name || '',
      cliente: {
        nome: deal.person_name,
        email: deal.person_id.email[0].value,
        fone: deal.person_id.phone[0].value
      }
    }

    if (deal.products_count) {
      const products = await this.getDealProducts(deal.id)

      if (!products) throw new Error()

      object.items = []

      for (const product of products) {
        object.items.push({
          item: {
            codigo: product.product_id,
            descricao: product.name,
            un: 'un',
            qtde: product.quantity,
            vlr_unit: product.sum
          }
        })
      }
    } else {
      object.itens = [
        {
          item: {
            codigo: 'XXX',
            descricao: 'Produto genÃ©rico',
            un: 'un',
            qtde: 1,
            vlr_unit: deal.weighted_value
          }
        }
      ]
    }

    return js2xmlparser.parse("pedido", object)
  }

  async getDealProducts (productId) {
    const productsRequest = await this.pipedriveApi.get(`deals/${productId}/products`)

    return productsRequest.data.data || false
  }

  async createPipedriveFilter (lastDate) {
    const date = new Date()
    const filterCreationRequest = await this.pipedriveApi.post('/filters', { 
      name: `[AUTOGENERATED] @${date.toJSON()}`,
      conditions: {
        glue: 'and',
        conditions: [
          {
            glue: 'and',
            conditions: [
              {
                object: 'deal',
                field_id: 12470,
                operator: '>=',
                value: lastDate,
                extra_value: null
              }
            ]
          },
          {
            glue: 'or', // Pipedrive own iterface creates this empty condition, leaved here for safety porpouses
            conditions: []
          }
        ],
      },
      type: 'deals'
    })

    if (!filterCreationRequest) throw new Error()

    return filterCreationRequest.data.data.id || false
  }
}