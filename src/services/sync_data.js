const pipedrive = require("../adapters/pipedrive_api")
const SyncDataController = require("../controllers/sync_data")
const js2xmlparser = require("js2xmlparser");
const { toXML } = require('jstoxml');

module.exports = class SyncDataService {
  constructor (BlingApiAdapter, PipedriveAdapter, DatabaseAdapter) {
    this.blingApi = BlingApiAdapter
    this.pipedriveApi = PipedriveAdapter
    this.database = DatabaseAdapter
  }

  async execute() {
    try {
      this.setLastExecution() // Here only for development porpouses
      const lastExecution = await this.getLastExecution()

      const filter_id = await this.createPipedriveFilter(lastExecution.wonDate)

      const dealsRequest = await this.pipedriveApi.get('deals', { params: { status: 'won', sort: 'id DESC', limit: 1000, filter_id } })

      const deals = dealsRequest.data.data
      for (const deal of deals) {
        const blingXml = await this.convertDealToXml(deal)
        const blingRequest = await this.blingApi.post('pedido/json/', { xml: encodeURIComponent(blingXml), apikey: process.env.BLING_API_KEY })
        console.log(blingRequest.data.retorno.erros)
      }

      return true

    } catch (error) {
      console.log('>>', error.response.data.retorno)
      return error
    }
  }

  async convertDealToXml (deal) { 
    const dealDate = new Date(deal.won_time)

    const formatedWonDate = `${dealDate.getDate() < 10 ? '0' + dealDate.getDate() : dealDate.getDate()}/${dealDate.getMonth() < 10 ? '0' + (dealDate.getMonth() + 1) : (dealDate.getMonth() + 1)}/${dealDate.getFullYear()}`
    
    const object = {
      data: formatedWonDate,
      numero: deal.id,
      vendedor: deal.user_id.name || '',
      cliente: {
        nome: deal.person_name,
        email: deal.person_id.email[0].value,
        fone: deal.person_id.phone[0].value
      }
    }

    if (deal.products_count) {
      const products = await this.getDealProducts(deal.id)

      if (!products) throw new Error()

      object.items = []

      for (const product of products) {
        object.items.push({
          item: {
            codigo: product.product_id,
            descricao: product.name,
            un: 'un',
            qtde: product.quantity,
            vlr_unit: product.sum
          }
        })
      }
    } else {
      object.itens = [
        {
          item: {
            codigo: 'XXX',
            descricao: 'Produto genÃ©rico',
            un: 'un',
            qtde: 1,
            vlr_unit: deal.weighted_value
          }
        }
      ]
    }

    return js2xmlparser.parse("pedido", object)
  }

  async getDealProducts (productId) {
    const productsRequest = await this.pipedriveApi.get(`deals/${productId}/products`)

    return productsRequest.data.data || false
  }

  async createPipedriveFilter (lastDate) {
    const date = new Date()
    const filterCreationRequest = await this.pipedriveApi.post('/filters', { 
      name: `[AUTOGENERATED] @${date.toJSON()}`,
      conditions: {
        glue: 'and',
        conditions: [
          {
            glue: 'and',
            conditions: [
              {
                object: 'deal',
                field_id: 12470,
                operator: '>=',
                value: lastDate,
                extra_value: null
              }
            ]
          },
          {
            glue: 'or', // Pipedrive own iterface creates this empty condition, leaved here for safety porpouses
            conditions: []
          }
        ],
      },
      type: 'deals'
    })

    if (!filterCreationRequest) throw new Error()

    return filterCreationRequest.data.data.id || false
  }

  async getLastExecution () {
    const query = await this.database.fetchMany('lastDeal', { dealId: -1 })
    return query[0]
  }

  async setLastExecution () {
    this.database.insert('lastDeal', {
      wonDate: '2021-03-23',
      runDate: '2021-03-25',
      dealId: 1
    })
  }
}